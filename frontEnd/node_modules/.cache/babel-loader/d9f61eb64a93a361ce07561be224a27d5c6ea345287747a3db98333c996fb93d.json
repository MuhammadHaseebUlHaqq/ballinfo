{"ast":null,"code":"import { io } from 'socket.io-client';\nclass SocketService {\n  constructor() {\n    var _process$env$REACT_AP, _process$env$REACT_AP2;\n    this.socket = null;\n    this.listeners = new Map();\n    this.eventCallbacks = new Map(); // Store actual socket.io event callbacks\n    this.connectionAttempts = 0;\n    this.maxRetries = 3;\n    this.debug = true;\n    this.isConnecting = false;\n    this.reconnectTimer = null;\n    this.hasConnectedBefore = false;\n    this.disabled = false; // Flag to disable socket completely if unreachable\n    this.requestedMatches = false;\n    this.connectionLock = false; // Add connection lock to prevent duplicate connections\n    this.persistConnection = true; // Add persistConnection flag to maintain connection between pages\n\n    // Get the socket URL from environment variables or use a fallback\n    this.socketUrl = ((_process$env$REACT_AP = process.env.REACT_APP_SOCKET_URL) === null || _process$env$REACT_AP === void 0 ? void 0 : _process$env$REACT_AP.trim()) || window.location.origin;\n    this.apiUrl = ((_process$env$REACT_AP2 = process.env.REACT_APP_API_URL) === null || _process$env$REACT_AP2 === void 0 ? void 0 : _process$env$REACT_AP2.trim()) || window.location.origin;\n    if (this.debug) {\n      console.log('SocketService Configuration:', {\n        socketUrl: this.socketUrl,\n        apiUrl: this.apiUrl,\n        env: process.env.NODE_ENV\n      });\n    }\n  }\n  connect() {\n    // Prevent multiple simultaneous connection attempts\n    if (this.connectionLock) {\n      console.log('Connection already in progress, skipping duplicate request');\n      return;\n    }\n\n    // Don't attempt to connect if service is disabled or already connecting/connected\n    if (this.disabled || this.socket || this.isConnecting) {\n      console.log('Skipping connection attempt:', {\n        disabled: this.disabled,\n        socketExists: !!this.socket,\n        isConnecting: this.isConnecting\n      });\n      return;\n    }\n    this.isConnecting = true;\n    this.connectionLock = true;\n    try {\n      console.log('Initiating new socket connection...');\n\n      // Create socket with options optimized for reliability\n      this.socket = io(this.socketUrl, {\n        reconnectionDelay: 1000,\n        reconnection: true,\n        reconnectionAttempts: 3,\n        transports: ['polling'],\n        // Only use polling for maximum compatibility\n        timeout: 10000,\n        // Shorter timeout for faster detection of issues\n        withCredentials: true,\n        autoConnect: true,\n        forceNew: true,\n        // Always create a new connection\n        path: '/socket.io',\n        query: {\n          timestamp: Date.now()\n        }\n      });\n      this.setupConnectionHandlers();\n    } catch (error) {\n      console.error('Error creating socket connection:', error);\n      this.handleConnectionError(error);\n    }\n  }\n  setupConnectionHandlers() {\n    if (!this.socket) {\n      this.connectionLock = false;\n      return;\n    }\n    this.socket.on('connect', () => {\n      var _this$socket, _this$socket$io, _this$socket$io$engin, _this$socket$io$engin2;\n      const transport = ((_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : (_this$socket$io = _this$socket.io) === null || _this$socket$io === void 0 ? void 0 : (_this$socket$io$engin = _this$socket$io.engine) === null || _this$socket$io$engin === void 0 ? void 0 : (_this$socket$io$engin2 = _this$socket$io$engin.transport) === null || _this$socket$io$engin2 === void 0 ? void 0 : _this$socket$io$engin2.name) || 'unknown';\n      console.log('Socket connected successfully:', {\n        transport: transport,\n        id: this.socket.id\n      });\n      this.connectionAttempts = 0;\n      this.isConnecting = false;\n      this.connectionLock = false;\n      this.hasConnectedBefore = true;\n      clearTimeout(this.reconnectTimer);\n\n      // Reattach all event listeners\n      this.reattachEventListeners();\n\n      // Request live matches immediately after connection\n      this.requestLiveMatches();\n    });\n    this.socket.on('connect_error', error => {\n      console.log('Socket connection error:', error.message);\n      this.connectionLock = false;\n      this.handleConnectionError(error);\n    });\n    this.socket.on('disconnect', reason => {\n      console.log('Socket disconnected. Reason:', reason);\n      this.isConnecting = false;\n      this.connectionLock = false;\n\n      // Handle intentional disconnections\n      if (reason === 'io client disconnect' || reason === 'io instance close' || this.disabled) {\n        this.socket = null;\n        return;\n      }\n    });\n    this.socket.on('error', error => {\n      console.log('Socket error event:', error.message || 'Unknown error');\n      if (this.listeners.has('error')) {\n        const callback = this.listeners.get('error');\n        callback(error);\n      }\n    });\n\n    // Add timeout for connection to complete\n    setTimeout(() => {\n      if (this.isConnecting && this.connectionLock) {\n        console.log('Connection attempt timed out');\n        this.connectionLock = false;\n        this.isConnecting = false;\n        if (this.socket) {\n          this.socket.disconnect();\n          this.socket = null;\n        }\n      }\n    }, 15000); // 15 second timeout\n  }\n  reattachEventListeners() {\n    // Only proceed if we have a valid socket\n    if (!this.socket || !this.socket.connected) return;\n    console.log('Reattaching event listeners...');\n\n    // Re-attach all event listeners from our registry\n    this.listeners.forEach((callback, event) => {\n      // Skip the connection events we manage internally\n      if (['connect', 'connect_error', 'disconnect', 'error'].includes(event)) {\n        return;\n      }\n\n      // Create a new callback wrapper and store it\n      const wrappedCallback = data => {\n        if (this.debug) console.log(`Received ${event} event:`, data);\n        callback(data);\n      };\n\n      // Store the actual callback reference\n      this.eventCallbacks.set(event, wrappedCallback);\n\n      // Attach the listener\n      console.log('Subscribing to event:', event);\n      this.socket.on(event, wrappedCallback);\n    });\n  }\n  handleConnectionError(error) {\n    var _error$message, _error$message$toLowe, _error$message$toLowe2, _error$message2, _error$message2$toLow, _error$message2$toLow2;\n    this.connectionAttempts++;\n    this.isConnecting = false;\n\n    // Check if the error is related to XHR polling\n    const isXHRError = ((_error$message = error.message) === null || _error$message === void 0 ? void 0 : (_error$message$toLowe = _error$message.toLowerCase) === null || _error$message$toLowe === void 0 ? void 0 : (_error$message$toLowe2 = _error$message$toLowe.call(_error$message)) === null || _error$message$toLowe2 === void 0 ? void 0 : _error$message$toLowe2.includes('xhr')) || ((_error$message2 = error.message) === null || _error$message2 === void 0 ? void 0 : (_error$message2$toLow = _error$message2.toLowerCase) === null || _error$message2$toLow === void 0 ? void 0 : (_error$message2$toLow2 = _error$message2$toLow.call(_error$message2)) === null || _error$message2$toLow2 === void 0 ? void 0 : _error$message2$toLow2.includes('polling'));\n    console.log(`Connection attempt ${this.connectionAttempts} failed:`, error.message);\n\n    // After 2 failed attempts, disable socket functionality entirely\n    if (this.connectionAttempts >= 2 || isXHRError) {\n      this.disabled = true;\n      const errorMessage = {\n        type: 'CONNECTION_ERROR',\n        message: `Socket connection unavailable (${error.message}). App will continue to function without live updates.`,\n        isXHRError: isXHRError\n      };\n      console.log('Socket service disabled due to connection issues');\n\n      // Clean up resources\n      if (this.socket) {\n        this.socket.disconnect();\n        this.socket = null;\n      }\n      this.isConnecting = false;\n      clearTimeout(this.reconnectTimer);\n      if (this.listeners.has('error')) {\n        const callback = this.listeners.get('error');\n        callback(errorMessage);\n      }\n    }\n  }\n  detectDevice() {\n    const userAgent = navigator.userAgent || navigator.vendor || window.opera;\n    const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());\n    return isMobile ? 'mobile' : 'desktop';\n  }\n  handleReconnect() {\n    // Prevent reconnecting if disabled or already connecting\n    if (this.disabled || this.isConnecting || this.connectionLock) {\n      console.log('Skipping reconnect attempt:', {\n        disabled: this.disabled,\n        isConnecting: this.isConnecting,\n        connectionLock: this.connectionLock\n      });\n      return;\n    }\n    console.log('Attempting to reconnect...');\n    clearTimeout(this.reconnectTimer);\n\n    // Use exponential backoff with a cap\n    const backoffDelay = Math.min(2000 * Math.pow(1.5, this.connectionAttempts - 1), 8000);\n    this.reconnectTimer = setTimeout(() => {\n      if (this.socket) {\n        // Clear existing socket first\n        this.socket.disconnect();\n        this.socket = null;\n      }\n      // Create new connection\n      this.connect();\n    }, backoffDelay);\n  }\n  requestLiveMatches() {\n    // Don't attempt if disabled\n    if (this.disabled || !this.socket || !this.socket.connected) {\n      var _this$socket2;\n      console.log(\"Cannot request matches - socket status:\", {\n        disabled: this.disabled,\n        socketExists: !!this.socket,\n        connected: (_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.connected\n      });\n      return;\n    }\n    console.log('Requesting live matches from server with socket ID:', this.socket.id);\n\n    // Track if we've already requested matches in this session\n    if (!this.requestedMatches) {\n      this.socket.emit('request_live_matches');\n      this.requestedMatches = true;\n      console.log('First live matches request sent');\n    } else {\n      console.log('Live matches already requested in this session');\n    }\n  }\n  emitError(error) {\n    const callback = this.listeners.get('error');\n    if (callback) {\n      callback(error);\n    }\n  }\n  disconnect() {\n    // Only disconnect when explicitly called by app shutdown\n    // Don't disconnect during page navigations\n    if (this.persistConnection) {\n      console.log('Skipping disconnect due to persistConnection flag');\n      return;\n    }\n\n    // Clear any pending reconnect attempts\n    clearTimeout(this.reconnectTimer);\n    if (this.socket) {\n      try {\n        console.log('Disconnecting socket...', this.socket.id);\n\n        // Reset request tracking\n        this.requestedMatches = false;\n\n        // Remove all listeners first to prevent reconnection triggers\n        this.socket.removeAllListeners();\n        this.eventCallbacks.clear();\n\n        // Then disconnect\n        this.socket.disconnect();\n      } catch (error) {\n        console.log('Error during socket disconnect:', error.message);\n      } finally {\n        // Always reset socket state\n        this.socket = null;\n        this.connectionAttempts = 0;\n        this.isConnecting = false;\n        this.connectionLock = false;\n        // Keep listeners for potential future connections\n      }\n    }\n  }\n  subscribe(event, callback) {\n    // Store the callback even if we can't connect now\n    this.listeners.set(event, callback);\n\n    // Don't try to subscribe if disabled\n    if (this.disabled) {\n      console.log(`Socket service disabled. Saving listener for ${event} without connecting.`);\n      return;\n    }\n\n    // Connect if needed\n    if (!this.socket) {\n      this.connect();\n      return; // The event will be attached during connection\n    }\n\n    // Add listener if socket exists and is connected\n    if (this.socket && this.socket.connected) {\n      console.log('Subscribing to event:', event);\n\n      // Create a wrapped callback function\n      const wrappedCallback = data => {\n        if (this.debug) console.log(`Received ${event} event:`, data);\n        callback(data);\n      };\n\n      // Store the callback reference\n      this.eventCallbacks.set(event, wrappedCallback);\n\n      // Attach the listener\n      this.socket.on(event, wrappedCallback);\n    }\n  }\n  unsubscribe(event) {\n    console.log('Unsubscribing from event:', event);\n\n    // Remove the callback from our registry\n    this.listeners.delete(event);\n\n    // Also remove from the socket if it exists and is connected\n    if (this.socket && this.socket.connected) {\n      const callback = this.eventCallbacks.get(event);\n      if (callback) {\n        this.socket.off(event, callback);\n        this.eventCallbacks.delete(event);\n      }\n    }\n  }\n  subscribeToMatch(matchId) {\n    // Don't try to subscribe if disabled\n    if (this.disabled) {\n      return;\n    }\n    if (!this.socket) {\n      this.connect();\n    }\n    if (!this.socket || !this.socket.connected) {\n      return;\n    }\n    console.log('Subscribing to match:', matchId);\n    this.socket.emit('subscribe_match', matchId);\n  }\n  unsubscribeFromMatch(matchId) {\n    if (!this.socket || !this.socket.connected) {\n      return;\n    }\n    console.log('Unsubscribing from match:', matchId);\n    this.socket.emit('unsubscribe_match', matchId);\n  }\n\n  // Add a method to allow component unmounting without disconnecting socket\n  releaseComponent() {\n    console.log('Component released socket connection, maintaining for app');\n    // Don't disconnect, just note that a component released its connection\n  }\n}\n\n// Create a singleton instance\nconst socketService = new SocketService();\n\n// Expose socketService to window for debugging\nif (process.env.NODE_ENV !== 'production') {\n  window.socketService = socketService;\n  console.log('socketService attached to window for debugging');\n}\nexport default socketService;","map":{"version":3,"names":["io","SocketService","constructor","_process$env$REACT_AP","_process$env$REACT_AP2","socket","listeners","Map","eventCallbacks","connectionAttempts","maxRetries","debug","isConnecting","reconnectTimer","hasConnectedBefore","disabled","requestedMatches","connectionLock","persistConnection","socketUrl","process","env","REACT_APP_SOCKET_URL","trim","window","location","origin","apiUrl","REACT_APP_API_URL","console","log","NODE_ENV","connect","socketExists","reconnectionDelay","reconnection","reconnectionAttempts","transports","timeout","withCredentials","autoConnect","forceNew","path","query","timestamp","Date","now","setupConnectionHandlers","error","handleConnectionError","on","_this$socket","_this$socket$io","_this$socket$io$engin","_this$socket$io$engin2","transport","engine","name","id","clearTimeout","reattachEventListeners","requestLiveMatches","message","reason","has","callback","get","setTimeout","disconnect","connected","forEach","event","includes","wrappedCallback","data","set","_error$message","_error$message$toLowe","_error$message$toLowe2","_error$message2","_error$message2$toLow","_error$message2$toLow2","isXHRError","toLowerCase","call","errorMessage","type","detectDevice","userAgent","navigator","vendor","opera","isMobile","test","handleReconnect","backoffDelay","Math","min","pow","_this$socket2","emit","emitError","removeAllListeners","clear","subscribe","unsubscribe","delete","off","subscribeToMatch","matchId","unsubscribeFromMatch","releaseComponent","socketService"],"sources":["E:/Muqtasid BS Computer Science/SPRING-25/Project/ballinfo/frontend/src/services/socketService.js"],"sourcesContent":["import { io } from 'socket.io-client';\n\nclass SocketService {\n    constructor() {\n        this.socket = null;\n        this.listeners = new Map();\n        this.eventCallbacks = new Map(); // Store actual socket.io event callbacks\n        this.connectionAttempts = 0;\n        this.maxRetries = 3;\n        this.debug = true;\n        this.isConnecting = false;\n        this.reconnectTimer = null;\n        this.hasConnectedBefore = false;\n        this.disabled = false; // Flag to disable socket completely if unreachable\n        this.requestedMatches = false;\n        this.connectionLock = false; // Add connection lock to prevent duplicate connections\n        this.persistConnection = true; // Add persistConnection flag to maintain connection between pages\n        \n        // Get the socket URL from environment variables or use a fallback\n        this.socketUrl = process.env.REACT_APP_SOCKET_URL?.trim() || window.location.origin;\n        this.apiUrl = process.env.REACT_APP_API_URL?.trim() || window.location.origin;\n        \n        if (this.debug) {\n            console.log('SocketService Configuration:', {\n                socketUrl: this.socketUrl,\n                apiUrl: this.apiUrl,\n                env: process.env.NODE_ENV\n            });\n        }\n    }\n\n    connect() {\n        // Prevent multiple simultaneous connection attempts\n        if (this.connectionLock) {\n            console.log('Connection already in progress, skipping duplicate request');\n            return;\n        }\n        \n        // Don't attempt to connect if service is disabled or already connecting/connected\n        if (this.disabled || this.socket || this.isConnecting) {\n            console.log('Skipping connection attempt:', {\n                disabled: this.disabled,\n                socketExists: !!this.socket,\n                isConnecting: this.isConnecting\n            });\n            return;\n        }\n\n        this.isConnecting = true;\n        this.connectionLock = true;\n        \n        try {\n            console.log('Initiating new socket connection...');\n            \n            // Create socket with options optimized for reliability\n            this.socket = io(this.socketUrl, {\n                reconnectionDelay: 1000,\n                reconnection: true,\n                reconnectionAttempts: 3,\n                transports: ['polling'], // Only use polling for maximum compatibility\n                timeout: 10000, // Shorter timeout for faster detection of issues\n                withCredentials: true,\n                autoConnect: true,\n                forceNew: true, // Always create a new connection\n                path: '/socket.io',\n                query: {\n                    timestamp: Date.now(),\n                }\n            });\n\n            this.setupConnectionHandlers();\n        } catch (error) {\n            console.error('Error creating socket connection:', error);\n            this.handleConnectionError(error);\n        }\n    }\n\n    setupConnectionHandlers() {\n        if (!this.socket) {\n            this.connectionLock = false;\n            return;\n        }\n\n        this.socket.on('connect', () => {\n            const transport = this.socket?.io?.engine?.transport?.name || 'unknown';\n            console.log('Socket connected successfully:', {\n                transport: transport,\n                id: this.socket.id\n            });\n            \n            this.connectionAttempts = 0;\n            this.isConnecting = false;\n            this.connectionLock = false;\n            this.hasConnectedBefore = true;\n            clearTimeout(this.reconnectTimer);\n            \n            // Reattach all event listeners\n            this.reattachEventListeners();\n            \n            // Request live matches immediately after connection\n            this.requestLiveMatches();\n        });\n\n        this.socket.on('connect_error', (error) => {\n            console.log('Socket connection error:', error.message);\n            this.connectionLock = false;\n            this.handleConnectionError(error);\n        });\n\n        this.socket.on('disconnect', (reason) => {\n            console.log('Socket disconnected. Reason:', reason);\n            this.isConnecting = false;\n            this.connectionLock = false;\n            \n            // Handle intentional disconnections\n            if (reason === 'io client disconnect' || \n                reason === 'io instance close' || \n                this.disabled) {\n                this.socket = null;\n                return;\n            }\n        });\n\n        this.socket.on('error', (error) => {\n            console.log('Socket error event:', error.message || 'Unknown error');\n            \n            if (this.listeners.has('error')) {\n                const callback = this.listeners.get('error');\n                callback(error);\n            }\n        });\n\n        // Add timeout for connection to complete\n        setTimeout(() => {\n            if (this.isConnecting && this.connectionLock) {\n                console.log('Connection attempt timed out');\n                this.connectionLock = false;\n                this.isConnecting = false;\n                \n                if (this.socket) {\n                    this.socket.disconnect();\n                    this.socket = null;\n                }\n            }\n        }, 15000); // 15 second timeout\n    }\n\n    reattachEventListeners() {\n        // Only proceed if we have a valid socket\n        if (!this.socket || !this.socket.connected) return;\n        \n        console.log('Reattaching event listeners...');\n        \n        // Re-attach all event listeners from our registry\n        this.listeners.forEach((callback, event) => {\n            // Skip the connection events we manage internally\n            if (['connect', 'connect_error', 'disconnect', 'error'].includes(event)) {\n                return;\n            }\n            \n            // Create a new callback wrapper and store it\n            const wrappedCallback = (data) => {\n                if (this.debug) console.log(`Received ${event} event:`, data);\n                callback(data);\n            };\n            \n            // Store the actual callback reference\n            this.eventCallbacks.set(event, wrappedCallback);\n            \n            // Attach the listener\n            console.log('Subscribing to event:', event);\n            this.socket.on(event, wrappedCallback);\n        });\n    }\n\n    handleConnectionError(error) {\n        this.connectionAttempts++;\n        this.isConnecting = false;\n        \n        // Check if the error is related to XHR polling\n        const isXHRError = error.message?.toLowerCase?.()?.includes('xhr') || \n                          error.message?.toLowerCase?.()?.includes('polling');\n        \n        console.log(`Connection attempt ${this.connectionAttempts} failed:`, error.message);\n        \n        // After 2 failed attempts, disable socket functionality entirely\n        if (this.connectionAttempts >= 2 || isXHRError) {\n            this.disabled = true;\n            \n            const errorMessage = {\n                type: 'CONNECTION_ERROR',\n                message: `Socket connection unavailable (${error.message}). App will continue to function without live updates.`,\n                isXHRError: isXHRError\n            };\n            \n            console.log('Socket service disabled due to connection issues');\n            \n            // Clean up resources\n            if (this.socket) {\n                this.socket.disconnect();\n                this.socket = null;\n            }\n            \n            this.isConnecting = false;\n            clearTimeout(this.reconnectTimer);\n            \n            if (this.listeners.has('error')) {\n                const callback = this.listeners.get('error');\n                callback(errorMessage);\n            }\n        }\n    }\n\n    detectDevice() {\n        const userAgent = navigator.userAgent || navigator.vendor || window.opera;\n        const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());\n        return isMobile ? 'mobile' : 'desktop';\n    }\n\n    handleReconnect() {\n        // Prevent reconnecting if disabled or already connecting\n        if (this.disabled || this.isConnecting || this.connectionLock) {\n            console.log('Skipping reconnect attempt:', {\n                disabled: this.disabled,\n                isConnecting: this.isConnecting,\n                connectionLock: this.connectionLock\n            });\n            return;\n        }\n        \n        console.log('Attempting to reconnect...');\n        clearTimeout(this.reconnectTimer);\n\n        // Use exponential backoff with a cap\n        const backoffDelay = Math.min(2000 * Math.pow(1.5, this.connectionAttempts - 1), 8000);\n\n        this.reconnectTimer = setTimeout(() => {\n            if (this.socket) {\n                // Clear existing socket first\n                this.socket.disconnect();\n                this.socket = null;\n            }\n            // Create new connection\n            this.connect();\n        }, backoffDelay);\n    }\n\n    requestLiveMatches() {\n        // Don't attempt if disabled\n        if (this.disabled || !this.socket || !this.socket.connected) {\n            console.log(\"Cannot request matches - socket status:\", {\n                disabled: this.disabled,\n                socketExists: !!this.socket,\n                connected: this.socket?.connected\n            });\n            return;\n        }\n        console.log('Requesting live matches from server with socket ID:', this.socket.id);\n        \n        // Track if we've already requested matches in this session\n        if (!this.requestedMatches) {\n            this.socket.emit('request_live_matches');\n            this.requestedMatches = true;\n            console.log('First live matches request sent');\n        } else {\n            console.log('Live matches already requested in this session');\n        }\n    }\n\n    emitError(error) {\n        const callback = this.listeners.get('error');\n        if (callback) {\n            callback(error);\n        }\n    }\n\n    disconnect() {\n        // Only disconnect when explicitly called by app shutdown\n        // Don't disconnect during page navigations\n        if (this.persistConnection) {\n            console.log('Skipping disconnect due to persistConnection flag');\n            return;\n        }\n        \n        // Clear any pending reconnect attempts\n        clearTimeout(this.reconnectTimer);\n        \n        if (this.socket) {\n            try {\n                console.log('Disconnecting socket...', this.socket.id);\n                \n                // Reset request tracking\n                this.requestedMatches = false;\n                \n                // Remove all listeners first to prevent reconnection triggers\n                this.socket.removeAllListeners();\n                this.eventCallbacks.clear();\n                \n                // Then disconnect\n                this.socket.disconnect();\n            } catch (error) {\n                console.log('Error during socket disconnect:', error.message);\n            } finally {\n                // Always reset socket state\n                this.socket = null;\n                this.connectionAttempts = 0;\n                this.isConnecting = false;\n                this.connectionLock = false;\n                // Keep listeners for potential future connections\n            }\n        }\n    }\n\n    subscribe(event, callback) {\n        // Store the callback even if we can't connect now\n        this.listeners.set(event, callback);\n        \n        // Don't try to subscribe if disabled\n        if (this.disabled) {\n            console.log(`Socket service disabled. Saving listener for ${event} without connecting.`);\n            return;\n        }\n        \n        // Connect if needed\n        if (!this.socket) {\n            this.connect();\n            return; // The event will be attached during connection\n        }\n        \n        // Add listener if socket exists and is connected\n        if (this.socket && this.socket.connected) {\n            console.log('Subscribing to event:', event);\n            \n            // Create a wrapped callback function\n            const wrappedCallback = (data) => {\n                if (this.debug) console.log(`Received ${event} event:`, data);\n                callback(data);\n            };\n            \n            // Store the callback reference\n            this.eventCallbacks.set(event, wrappedCallback);\n            \n            // Attach the listener\n            this.socket.on(event, wrappedCallback);\n        }\n    }\n\n    unsubscribe(event) {\n        console.log('Unsubscribing from event:', event);\n        \n        // Remove the callback from our registry\n        this.listeners.delete(event);\n        \n        // Also remove from the socket if it exists and is connected\n        if (this.socket && this.socket.connected) {\n            const callback = this.eventCallbacks.get(event);\n            if (callback) {\n                this.socket.off(event, callback);\n                this.eventCallbacks.delete(event);\n            }\n        }\n    }\n\n    subscribeToMatch(matchId) {\n        // Don't try to subscribe if disabled\n        if (this.disabled) {\n            return;\n        }\n        \n        if (!this.socket) {\n            this.connect();\n        }\n        \n        if (!this.socket || !this.socket.connected) {\n            return;\n        }\n        \n        console.log('Subscribing to match:', matchId);\n        this.socket.emit('subscribe_match', matchId);\n    }\n\n    unsubscribeFromMatch(matchId) {\n        if (!this.socket || !this.socket.connected) {\n            return;\n        }\n        \n        console.log('Unsubscribing from match:', matchId);\n        this.socket.emit('unsubscribe_match', matchId);\n    }\n\n    // Add a method to allow component unmounting without disconnecting socket\n    releaseComponent() {\n        console.log('Component released socket connection, maintaining for app');\n        // Don't disconnect, just note that a component released its connection\n    }\n}\n\n// Create a singleton instance\nconst socketService = new SocketService();\n\n// Expose socketService to window for debugging\nif (process.env.NODE_ENV !== 'production') {\n  window.socketService = socketService;\n  console.log('socketService attached to window for debugging');\n}\n\nexport default socketService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}