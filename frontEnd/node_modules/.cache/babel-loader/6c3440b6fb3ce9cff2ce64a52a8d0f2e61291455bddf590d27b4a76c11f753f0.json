{"ast":null,"code":"import { io } from 'socket.io-client';\nclass SocketService {\n  constructor() {\n    this.socket = null;\n    this.listeners = new Map();\n    this.connectionAttempts = 0;\n    this.maxAttempts = 3;\n    this.isConnecting = false;\n    this.defaultPort = '3000';\n  }\n  async connect() {\n    return new Promise((resolve, reject) => {\n      var _this$socket;\n      if ((_this$socket = this.socket) !== null && _this$socket !== void 0 && _this$socket.connected) {\n        resolve();\n        return;\n      }\n      if (this.isConnecting) {\n        resolve();\n        return;\n      }\n      if (this.connectionAttempts >= this.maxAttempts) {\n        reject(new Error('Maximum connection attempts reached'));\n        return;\n      }\n      this.isConnecting = true;\n\n      // Force close any existing socket\n      if (this.socket) {\n        this.socket.close();\n        this.socket = null;\n      }\n      try {\n        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n        const hostname = window.location.hostname === 'localhost' ? 'localhost' : window.location.hostname;\n        const socketUrl = process.env.REACT_APP_API_URL || `${protocol}//${hostname}:${this.defaultPort}`;\n        console.log('Attempting to connect to:', socketUrl);\n        this.socket = io(socketUrl, {\n          reconnectionDelay: 1000,\n          reconnection: true,\n          reconnectionAttempts: 3,\n          transports: ['polling', 'websocket'],\n          timeout: 10000,\n          agent: false,\n          upgrade: true,\n          rejectUnauthorized: false,\n          path: '/socket.io',\n          withCredentials: true,\n          forceNew: true,\n          autoConnect: false\n        });\n\n        // Setup connection handlers\n        this.socket.on('connect', () => {\n          console.log('Connected to WebSocket server');\n          this.connectionAttempts = 0;\n          this.isConnecting = false;\n          resolve();\n        });\n        this.socket.on('connect_error', error => {\n          console.error('Connection error:', error.message);\n          this.connectionAttempts++;\n          if (this.connectionAttempts >= this.maxAttempts) {\n            this.isConnecting = false;\n            reject(new Error(`Failed to connect: ${error.message}`));\n          } else {\n            console.log(`Retrying connection... Attempt ${this.connectionAttempts} of ${this.maxAttempts}`);\n            // Try to reconnect with polling if websocket fails\n            this.socket.io.opts.transports = ['polling'];\n          }\n        });\n        this.socket.on('disconnect', reason => {\n          console.log('Disconnected from WebSocket server:', reason);\n          if (reason === 'io server disconnect') {\n            // Reconnect if server disconnected\n            this.socket.connect();\n          }\n        });\n        this.socket.on('error', error => {\n          console.error('Socket error:', error);\n          this.isConnecting = false;\n          reject(error);\n        });\n\n        // Add connection timeout\n        const connectionTimeout = setTimeout(() => {\n          if (!this.socket.connected) {\n            this.isConnecting = false;\n            reject(new Error('Connection timeout'));\n          }\n        }, 10000);\n\n        // Clean up timeout on success\n        this.socket.on('connect', () => {\n          clearTimeout(connectionTimeout);\n        });\n\n        // Attempt to connect\n        this.socket.connect();\n      } catch (error) {\n        console.error('Socket initialization error:', error);\n        this.isConnecting = false;\n        reject(error);\n      }\n    });\n  }\n  disconnect() {\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n      this.connectionAttempts = 0;\n      this.isConnecting = false;\n    }\n  }\n  subscribe(event, callback) {\n    const wrappedCallback = (...args) => {\n      try {\n        callback(...args);\n      } catch (error) {\n        console.error(`Error in ${event} callback:`, error);\n      }\n    };\n    if (!this.socket || !this.socket.connected) {\n      this.connect().then(() => {\n        this.socket.on(event, wrappedCallback);\n        this.listeners.set(event, wrappedCallback);\n      }).catch(error => {\n        console.error('Failed to connect:', error);\n        if (event === 'error') {\n          wrappedCallback({\n            message: `Failed to connect to server: ${error.message}`\n          });\n        }\n      });\n    } else {\n      this.socket.on(event, wrappedCallback);\n      this.listeners.set(event, wrappedCallback);\n    }\n  }\n  unsubscribe(event) {\n    if (!this.socket) return;\n    const callback = this.listeners.get(event);\n    if (callback) {\n      this.socket.off(event, callback);\n      this.listeners.delete(event);\n    }\n  }\n  subscribeToMatch(matchId) {\n    if (!this.socket || !this.socket.connected) {\n      this.connect().then(() => this.socket.emit('subscribe_match', matchId)).catch(error => {\n        console.error('Failed to subscribe to match:', error);\n      });\n    } else {\n      this.socket.emit('subscribe_match', matchId);\n    }\n  }\n  unsubscribeFromMatch(matchId) {\n    if (!this.socket || !this.socket.connected) return;\n    this.socket.emit('unsubscribe_match', matchId);\n  }\n}\nconst socketService = new SocketService();\nexport default socketService;","map":{"version":3,"names":["io","SocketService","constructor","socket","listeners","Map","connectionAttempts","maxAttempts","isConnecting","defaultPort","connect","Promise","resolve","reject","_this$socket","connected","Error","close","protocol","window","location","hostname","socketUrl","process","env","REACT_APP_API_URL","console","log","reconnectionDelay","reconnection","reconnectionAttempts","transports","timeout","agent","upgrade","rejectUnauthorized","path","withCredentials","forceNew","autoConnect","on","error","message","opts","reason","connectionTimeout","setTimeout","clearTimeout","disconnect","subscribe","event","callback","wrappedCallback","args","then","set","catch","unsubscribe","get","off","delete","subscribeToMatch","matchId","emit","unsubscribeFromMatch","socketService"],"sources":["E:/Muqtasid BS Computer Science/SPRING-25/Project/ballinfo/frontEnd/src/services/socketService.js"],"sourcesContent":["import { io } from 'socket.io-client';\n\nclass SocketService {\n    constructor() {\n        this.socket = null;\n        this.listeners = new Map();\n        this.connectionAttempts = 0;\n        this.maxAttempts = 3;\n        this.isConnecting = false;\n        this.defaultPort = '3000';\n    }\n\n    async connect() {\n        return new Promise((resolve, reject) => {\n            if (this.socket?.connected) {\n                resolve();\n                return;\n            }\n\n            if (this.isConnecting) {\n                resolve();\n                return;\n            }\n\n            if (this.connectionAttempts >= this.maxAttempts) {\n                reject(new Error('Maximum connection attempts reached'));\n                return;\n            }\n\n            this.isConnecting = true;\n\n            // Force close any existing socket\n            if (this.socket) {\n                this.socket.close();\n                this.socket = null;\n            }\n\n            try {\n                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n                const hostname = window.location.hostname === 'localhost' ? 'localhost' : window.location.hostname;\n                const socketUrl = process.env.REACT_APP_API_URL || `${protocol}//${hostname}:${this.defaultPort}`;\n\n                console.log('Attempting to connect to:', socketUrl);\n\n                this.socket = io(socketUrl, {\n                    reconnectionDelay: 1000,\n                    reconnection: true,\n                    reconnectionAttempts: 3,\n                    transports: ['polling', 'websocket'],\n                    timeout: 10000,\n                    agent: false,\n                    upgrade: true,\n                    rejectUnauthorized: false,\n                    path: '/socket.io',\n                    withCredentials: true,\n                    forceNew: true,\n                    autoConnect: false\n                });\n\n                // Setup connection handlers\n                this.socket.on('connect', () => {\n                    console.log('Connected to WebSocket server');\n                    this.connectionAttempts = 0;\n                    this.isConnecting = false;\n                    resolve();\n                });\n\n                this.socket.on('connect_error', (error) => {\n                    console.error('Connection error:', error.message);\n                    this.connectionAttempts++;\n                    \n                    if (this.connectionAttempts >= this.maxAttempts) {\n                        this.isConnecting = false;\n                        reject(new Error(`Failed to connect: ${error.message}`));\n                    } else {\n                        console.log(`Retrying connection... Attempt ${this.connectionAttempts} of ${this.maxAttempts}`);\n                        // Try to reconnect with polling if websocket fails\n                        this.socket.io.opts.transports = ['polling'];\n                    }\n                });\n\n                this.socket.on('disconnect', (reason) => {\n                    console.log('Disconnected from WebSocket server:', reason);\n                    if (reason === 'io server disconnect') {\n                        // Reconnect if server disconnected\n                        this.socket.connect();\n                    }\n                });\n\n                this.socket.on('error', (error) => {\n                    console.error('Socket error:', error);\n                    this.isConnecting = false;\n                    reject(error);\n                });\n\n                // Add connection timeout\n                const connectionTimeout = setTimeout(() => {\n                    if (!this.socket.connected) {\n                        this.isConnecting = false;\n                        reject(new Error('Connection timeout'));\n                    }\n                }, 10000);\n\n                // Clean up timeout on success\n                this.socket.on('connect', () => {\n                    clearTimeout(connectionTimeout);\n                });\n\n                // Attempt to connect\n                this.socket.connect();\n\n            } catch (error) {\n                console.error('Socket initialization error:', error);\n                this.isConnecting = false;\n                reject(error);\n            }\n        });\n    }\n\n    disconnect() {\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n            this.connectionAttempts = 0;\n            this.isConnecting = false;\n        }\n    }\n\n    subscribe(event, callback) {\n        const wrappedCallback = (...args) => {\n            try {\n                callback(...args);\n            } catch (error) {\n                console.error(`Error in ${event} callback:`, error);\n            }\n        };\n\n        if (!this.socket || !this.socket.connected) {\n            this.connect()\n                .then(() => {\n                    this.socket.on(event, wrappedCallback);\n                    this.listeners.set(event, wrappedCallback);\n                })\n                .catch(error => {\n                    console.error('Failed to connect:', error);\n                    if (event === 'error') {\n                        wrappedCallback({ message: `Failed to connect to server: ${error.message}` });\n                    }\n                });\n        } else {\n            this.socket.on(event, wrappedCallback);\n            this.listeners.set(event, wrappedCallback);\n        }\n    }\n\n    unsubscribe(event) {\n        if (!this.socket) return;\n\n        const callback = this.listeners.get(event);\n        if (callback) {\n            this.socket.off(event, callback);\n            this.listeners.delete(event);\n        }\n    }\n\n    subscribeToMatch(matchId) {\n        if (!this.socket || !this.socket.connected) {\n            this.connect()\n                .then(() => this.socket.emit('subscribe_match', matchId))\n                .catch(error => {\n                    console.error('Failed to subscribe to match:', error);\n                });\n        } else {\n            this.socket.emit('subscribe_match', matchId);\n        }\n    }\n\n    unsubscribeFromMatch(matchId) {\n        if (!this.socket || !this.socket.connected) return;\n        this.socket.emit('unsubscribe_match', matchId);\n    }\n}\n\nconst socketService = new SocketService();\nexport default socketService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}