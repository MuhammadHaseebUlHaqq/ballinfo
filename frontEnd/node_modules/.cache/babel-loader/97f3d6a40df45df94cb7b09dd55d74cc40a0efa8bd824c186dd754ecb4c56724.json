{"ast":null,"code":"import { io } from 'socket.io-client';\nclass SocketService {\n  constructor() {\n    this.socket = null;\n    this.listeners = new Map();\n    this.connectionAttempts = 0;\n    this.maxAttempts = 3;\n    this.isConnecting = false;\n  }\n  async connect() {\n    return new Promise((resolve, reject) => {\n      var _this$socket;\n      if ((_this$socket = this.socket) !== null && _this$socket !== void 0 && _this$socket.connected) {\n        resolve();\n        return;\n      }\n      if (this.isConnecting) {\n        resolve();\n        return;\n      }\n      if (this.connectionAttempts >= this.maxAttempts) {\n        reject(new Error('Maximum connection attempts reached'));\n        return;\n      }\n      this.isConnecting = true;\n\n      // Force close any existing socket\n      if (this.socket) {\n        this.socket.close();\n        this.socket = null;\n      }\n      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n      const host = process.env.REACT_APP_API_URL || window.location.hostname + ':3000';\n      const socketUrl = `${protocol}//${host}`;\n      this.socket = io(socketUrl, {\n        reconnectionDelay: 1000,\n        reconnection: true,\n        reconnectionAttempts: 3,\n        transports: ['polling', 'websocket'],\n        // Start with polling, upgrade to websocket\n        timeout: 10000,\n        agent: false,\n        upgrade: true,\n        rejectUnauthorized: false,\n        path: '/socket.io',\n        withCredentials: true,\n        forceNew: true,\n        autoConnect: false\n      });\n\n      // Setup connection handlers\n      this.socket.on('connect', () => {\n        console.log('Connected to WebSocket server');\n        this.connectionAttempts = 0;\n        this.isConnecting = false;\n        resolve();\n      });\n      this.socket.on('connect_error', error => {\n        console.error('Connection error:', error);\n        this.connectionAttempts++;\n        if (this.connectionAttempts >= this.maxAttempts) {\n          this.isConnecting = false;\n          reject(new Error('Failed to connect after multiple attempts'));\n        } else {\n          // Try to reconnect with polling if websocket fails\n          this.socket.io.opts.transports = ['polling'];\n        }\n      });\n      this.socket.on('disconnect', reason => {\n        console.log('Disconnected from WebSocket server:', reason);\n        if (reason === 'io server disconnect') {\n          // Reconnect if server disconnected\n          this.socket.connect();\n        }\n      });\n      this.socket.on('error', error => {\n        console.error('Socket error:', error);\n        this.isConnecting = false;\n        reject(error);\n      });\n\n      // Add connection timeout\n      const connectionTimeout = setTimeout(() => {\n        if (!this.socket.connected) {\n          this.isConnecting = false;\n          reject(new Error('Connection timeout'));\n        }\n      }, 10000);\n\n      // Clean up timeout on success\n      this.socket.on('connect', () => {\n        clearTimeout(connectionTimeout);\n      });\n\n      // Attempt to connect\n      try {\n        this.socket.connect();\n      } catch (error) {\n        this.isConnecting = false;\n        reject(error);\n      }\n    });\n  }\n  disconnect() {\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n      this.connectionAttempts = 0;\n      this.isConnecting = false;\n    }\n  }\n  subscribe(event, callback) {\n    const wrappedCallback = (...args) => {\n      try {\n        callback(...args);\n      } catch (error) {\n        console.error(`Error in ${event} callback:`, error);\n      }\n    };\n    if (!this.socket || !this.socket.connected) {\n      this.connect().then(() => {\n        this.socket.on(event, wrappedCallback);\n        this.listeners.set(event, wrappedCallback);\n      }).catch(error => {\n        console.error('Failed to connect:', error);\n        if (event === 'error') {\n          wrappedCallback({\n            message: 'Failed to connect to server'\n          });\n        }\n      });\n    } else {\n      this.socket.on(event, wrappedCallback);\n      this.listeners.set(event, wrappedCallback);\n    }\n  }\n  unsubscribe(event) {\n    if (!this.socket) return;\n    const callback = this.listeners.get(event);\n    if (callback) {\n      this.socket.off(event, callback);\n      this.listeners.delete(event);\n    }\n  }\n  subscribeToMatch(matchId) {\n    if (!this.socket || !this.socket.connected) {\n      this.connect().then(() => this.socket.emit('subscribe_match', matchId)).catch(console.error);\n    } else {\n      this.socket.emit('subscribe_match', matchId);\n    }\n  }\n  unsubscribeFromMatch(matchId) {\n    if (!this.socket || !this.socket.connected) return;\n    this.socket.emit('unsubscribe_match', matchId);\n  }\n}\nconst socketService = new SocketService();\nexport default socketService;","map":{"version":3,"names":["io","SocketService","constructor","socket","listeners","Map","connectionAttempts","maxAttempts","isConnecting","connect","Promise","resolve","reject","_this$socket","connected","Error","close","protocol","window","location","host","process","env","REACT_APP_API_URL","hostname","socketUrl","reconnectionDelay","reconnection","reconnectionAttempts","transports","timeout","agent","upgrade","rejectUnauthorized","path","withCredentials","forceNew","autoConnect","on","console","log","error","opts","reason","connectionTimeout","setTimeout","clearTimeout","disconnect","subscribe","event","callback","wrappedCallback","args","then","set","catch","message","unsubscribe","get","off","delete","subscribeToMatch","matchId","emit","unsubscribeFromMatch","socketService"],"sources":["E:/Muqtasid BS Computer Science/SPRING-25/Project/ballinfo/frontEnd/src/services/socketService.js"],"sourcesContent":["import { io } from 'socket.io-client';\n\nclass SocketService {\n    constructor() {\n        this.socket = null;\n        this.listeners = new Map();\n        this.connectionAttempts = 0;\n        this.maxAttempts = 3;\n        this.isConnecting = false;\n    }\n\n    async connect() {\n        return new Promise((resolve, reject) => {\n            if (this.socket?.connected) {\n                resolve();\n                return;\n            }\n\n            if (this.isConnecting) {\n                resolve();\n                return;\n            }\n\n            if (this.connectionAttempts >= this.maxAttempts) {\n                reject(new Error('Maximum connection attempts reached'));\n                return;\n            }\n\n            this.isConnecting = true;\n\n            // Force close any existing socket\n            if (this.socket) {\n                this.socket.close();\n                this.socket = null;\n            }\n\n            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n            const host = process.env.REACT_APP_API_URL || window.location.hostname + ':3000';\n            const socketUrl = `${protocol}//${host}`;\n\n            this.socket = io(socketUrl, {\n                reconnectionDelay: 1000,\n                reconnection: true,\n                reconnectionAttempts: 3,\n                transports: ['polling', 'websocket'], // Start with polling, upgrade to websocket\n                timeout: 10000,\n                agent: false,\n                upgrade: true,\n                rejectUnauthorized: false,\n                path: '/socket.io',\n                withCredentials: true,\n                forceNew: true,\n                autoConnect: false\n            });\n\n            // Setup connection handlers\n            this.socket.on('connect', () => {\n                console.log('Connected to WebSocket server');\n                this.connectionAttempts = 0;\n                this.isConnecting = false;\n                resolve();\n            });\n\n            this.socket.on('connect_error', (error) => {\n                console.error('Connection error:', error);\n                this.connectionAttempts++;\n                if (this.connectionAttempts >= this.maxAttempts) {\n                    this.isConnecting = false;\n                    reject(new Error('Failed to connect after multiple attempts'));\n                } else {\n                    // Try to reconnect with polling if websocket fails\n                    this.socket.io.opts.transports = ['polling'];\n                }\n            });\n\n            this.socket.on('disconnect', (reason) => {\n                console.log('Disconnected from WebSocket server:', reason);\n                if (reason === 'io server disconnect') {\n                    // Reconnect if server disconnected\n                    this.socket.connect();\n                }\n            });\n\n            this.socket.on('error', (error) => {\n                console.error('Socket error:', error);\n                this.isConnecting = false;\n                reject(error);\n            });\n\n            // Add connection timeout\n            const connectionTimeout = setTimeout(() => {\n                if (!this.socket.connected) {\n                    this.isConnecting = false;\n                    reject(new Error('Connection timeout'));\n                }\n            }, 10000);\n\n            // Clean up timeout on success\n            this.socket.on('connect', () => {\n                clearTimeout(connectionTimeout);\n            });\n\n            // Attempt to connect\n            try {\n                this.socket.connect();\n            } catch (error) {\n                this.isConnecting = false;\n                reject(error);\n            }\n        });\n    }\n\n    disconnect() {\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n            this.connectionAttempts = 0;\n            this.isConnecting = false;\n        }\n    }\n\n    subscribe(event, callback) {\n        const wrappedCallback = (...args) => {\n            try {\n                callback(...args);\n            } catch (error) {\n                console.error(`Error in ${event} callback:`, error);\n            }\n        };\n\n        if (!this.socket || !this.socket.connected) {\n            this.connect()\n                .then(() => {\n                    this.socket.on(event, wrappedCallback);\n                    this.listeners.set(event, wrappedCallback);\n                })\n                .catch(error => {\n                    console.error('Failed to connect:', error);\n                    if (event === 'error') {\n                        wrappedCallback({ message: 'Failed to connect to server' });\n                    }\n                });\n        } else {\n            this.socket.on(event, wrappedCallback);\n            this.listeners.set(event, wrappedCallback);\n        }\n    }\n\n    unsubscribe(event) {\n        if (!this.socket) return;\n\n        const callback = this.listeners.get(event);\n        if (callback) {\n            this.socket.off(event, callback);\n            this.listeners.delete(event);\n        }\n    }\n\n    subscribeToMatch(matchId) {\n        if (!this.socket || !this.socket.connected) {\n            this.connect()\n                .then(() => this.socket.emit('subscribe_match', matchId))\n                .catch(console.error);\n        } else {\n            this.socket.emit('subscribe_match', matchId);\n        }\n    }\n\n    unsubscribeFromMatch(matchId) {\n        if (!this.socket || !this.socket.connected) return;\n        this.socket.emit('unsubscribe_match', matchId);\n    }\n}\n\nconst socketService = new SocketService();\nexport default socketService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}