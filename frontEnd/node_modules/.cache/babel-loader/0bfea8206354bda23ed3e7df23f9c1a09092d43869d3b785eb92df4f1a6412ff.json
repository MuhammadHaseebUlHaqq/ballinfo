{"ast":null,"code":"import { io } from 'socket.io-client';\nclass SocketService {\n  constructor() {\n    var _process$env$REACT_AP, _process$env$REACT_AP2;\n    this.socket = null;\n    this.listeners = new Map();\n    this.connectionAttempts = 0;\n    this.maxRetries = 3;\n    this.debug = true;\n    this.isConnecting = false;\n    this.reconnectTimer = null;\n    this.hasConnectedBefore = false;\n\n    // Get the socket URL from environment variables or use a fallback\n    this.socketUrl = ((_process$env$REACT_AP = process.env.REACT_APP_SOCKET_URL) === null || _process$env$REACT_AP === void 0 ? void 0 : _process$env$REACT_AP.trim()) || window.location.origin;\n    this.apiUrl = ((_process$env$REACT_AP2 = process.env.REACT_APP_API_URL) === null || _process$env$REACT_AP2 === void 0 ? void 0 : _process$env$REACT_AP2.trim()) || window.location.origin;\n    if (this.debug) {\n      console.log('SocketService Configuration:', {\n        socketUrl: this.socketUrl,\n        apiUrl: this.apiUrl,\n        env: process.env.NODE_ENV\n      });\n    }\n  }\n  connect() {\n    if (this.socket || this.isConnecting) return;\n    this.isConnecting = true;\n    const isMobile = this.detectDevice() === 'mobile';\n    console.log('Attempting to connect to:', this.socketUrl, 'Device type:', this.detectDevice());\n    try {\n      this.socket = io(this.socketUrl, {\n        reconnectionDelay: 1000,\n        reconnection: true,\n        reconnectionAttempts: 5,\n        transports: ['polling', 'websocket'],\n        upgrade: false,\n        rememberUpgrade: false,\n        timeout: 20000,\n        withCredentials: true,\n        autoConnect: true,\n        forceNew: true,\n        path: '/socket.io',\n        query: {\n          device: this.detectDevice(),\n          timestamp: Date.now(),\n          debug: this.debug\n        }\n      });\n\n      // Add connection state logging\n      this.socket.io.on('ping', () => {\n        if (this.debug) console.log('Socket ping sent');\n      });\n      this.socket.io.on('pong', latency => {\n        if (this.debug) console.log('Socket pong received, latency:', latency, 'ms');\n      });\n      this.setupConnectionHandlers();\n    } catch (error) {\n      console.error('Error creating socket connection:', error);\n      this.handleConnectionError(error);\n    }\n  }\n  setupConnectionHandlers() {\n    if (!this.socket) return;\n    this.socket.on('connect', () => {\n      var _this$socket, _this$socket$io, _this$socket$io$engin, _this$socket$io$engin2;\n      const transport = ((_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : (_this$socket$io = _this$socket.io) === null || _this$socket$io === void 0 ? void 0 : (_this$socket$io$engin = _this$socket$io.engine) === null || _this$socket$io$engin === void 0 ? void 0 : (_this$socket$io$engin2 = _this$socket$io$engin.transport) === null || _this$socket$io$engin2 === void 0 ? void 0 : _this$socket$io$engin2.name) || 'unknown';\n      console.log('Socket connected successfully.', {\n        transport: transport,\n        id: this.socket.id,\n        device: this.detectDevice()\n      });\n      this.connectionAttempts = 0;\n      this.isConnecting = false;\n      this.hasConnectedBefore = true;\n      clearTimeout(this.reconnectTimer);\n\n      // Request live matches immediately after connection\n      this.requestLiveMatches();\n    });\n    this.socket.on('connect_error', error => {\n      console.error('Socket connection error:', error);\n      this.handleConnectionError(error);\n    });\n    this.socket.on('disconnect', reason => {\n      console.log('Socket disconnected. Reason:', reason);\n      this.isConnecting = false;\n      if (reason === 'io client disconnect' || reason === 'io instance close') {\n        this.socket = null;\n        return;\n      }\n      if (reason === 'io server disconnect' || reason === 'transport close') {\n        this.handleReconnect();\n      }\n    });\n    this.socket.on('error', error => {\n      console.error('Socket error event:', error);\n      this.emitError(error);\n    });\n\n    // Monitor connection state\n    this.socket.io.on('reconnect_attempt', attempt => {\n      console.log(`Reconnection attempt ${attempt}`);\n    });\n    this.socket.io.on('reconnect_failed', () => {\n      console.log('Reconnection failed');\n      this.handleConnectionError(new Error('Reconnection failed'));\n    });\n  }\n  detectDevice() {\n    const userAgent = navigator.userAgent || navigator.vendor || window.opera;\n    const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());\n    return isMobile ? 'mobile' : 'desktop';\n  }\n  handleConnectionError(error) {\n    var _error$message, _error$message$toLowe, _error$message$toLowe2, _error$message2, _error$message2$toLow, _error$message2$toLow2;\n    this.connectionAttempts++;\n    this.isConnecting = false;\n    console.log(`Connection attempt ${this.connectionAttempts} failed:`, error.message);\n\n    // Check if the error is related to XHR polling\n    const isXHRError = ((_error$message = error.message) === null || _error$message === void 0 ? void 0 : (_error$message$toLowe = _error$message.toLowerCase) === null || _error$message$toLowe === void 0 ? void 0 : (_error$message$toLowe2 = _error$message$toLowe.call(_error$message)) === null || _error$message$toLowe2 === void 0 ? void 0 : _error$message$toLowe2.includes('xhr')) || ((_error$message2 = error.message) === null || _error$message2 === void 0 ? void 0 : (_error$message2$toLow = _error$message2.toLowerCase) === null || _error$message2$toLow === void 0 ? void 0 : (_error$message2$toLow2 = _error$message2$toLow.call(_error$message2)) === null || _error$message2$toLow2 === void 0 ? void 0 : _error$message2$toLow2.includes('polling'));\n\n    // Don't block UI or prevent navigation due to socket errors\n    if (this.connectionAttempts >= this.maxRetries || isXHRError) {\n      const errorMessage = {\n        type: 'CONNECTION_ERROR',\n        message: `Socket connection unavailable (${error.message}). App will continue to function without live updates.`,\n        isXHRError: isXHRError\n      };\n      console.error('Max retries reached or XHR error detected:', errorMessage);\n      this.emitError(errorMessage);\n\n      // Clean up and don't retry\n      if (this.socket) {\n        this.socket.disconnect();\n        this.socket = null;\n      }\n      this.isConnecting = false;\n      this.connectionAttempts = 0;\n      clearTimeout(this.reconnectTimer);\n    } else if (this.hasConnectedBefore) {\n      // Only try to reconnect if we've successfully connected before\n      this.handleReconnect();\n    } else {\n      // If we've never connected before, just clean up and give up\n      if (this.socket) {\n        this.socket.disconnect();\n        this.socket = null;\n      }\n      this.isConnecting = false;\n    }\n  }\n  handleReconnect() {\n    console.log('Attempting to reconnect...');\n    clearTimeout(this.reconnectTimer);\n\n    // Use exponential backoff with a cap\n    const backoffDelay = Math.min(2000 * Math.pow(1.5, this.connectionAttempts - 1), 8000);\n    this.reconnectTimer = setTimeout(() => {\n      if (this.socket) {\n        // Clear existing socket first\n        this.socket.disconnect();\n        this.socket = null;\n      }\n      // Create new connection\n      this.connect();\n    }, backoffDelay);\n  }\n  requestLiveMatches() {\n    if (!this.socket || !this.socket.connected) {\n      console.log('Cannot request matches: No active socket connection');\n      return;\n    }\n    console.log('Requesting live matches from server');\n    this.socket.emit('request_live_matches');\n  }\n  emitError(error) {\n    const callback = this.listeners.get('error');\n    if (callback) {\n      callback(error);\n    }\n  }\n  disconnect() {\n    // Clear any pending reconnect attempts\n    clearTimeout(this.reconnectTimer);\n    if (this.socket) {\n      try {\n        console.log('Disconnecting socket...');\n\n        // Remove all listeners first to prevent reconnection triggers\n        this.socket.removeAllListeners();\n        this.socket.io.removeAllListeners();\n\n        // Then disconnect\n        this.socket.disconnect();\n      } catch (error) {\n        console.error('Error during socket disconnect:', error);\n        // Continue with cleanup regardless of errors\n      } finally {\n        // Always reset socket state\n        this.socket = null;\n        this.connectionAttempts = 0;\n        this.isConnecting = false;\n        this.listeners.clear();\n      }\n    }\n  }\n  subscribe(event, callback) {\n    // Connect if needed, but don't block or throw errors\n    if (!this.socket) {\n      console.log('No socket connection, attempting to connect...');\n      this.connect();\n\n      // If still no socket, just record the listener without subscribing\n      if (!this.socket) {\n        console.log(`Saving listener for ${event} without socket connection`);\n        this.listeners.set(event, callback);\n        return;\n      }\n    }\n    console.log('Subscribing to event:', event);\n\n    // Store callback and add listener if socket exists\n    if (this.socket) {\n      this.socket.on(event, data => {\n        if (this.debug) console.log(`Received ${event} event:`, data);\n        callback(data);\n      });\n    }\n\n    // Always store the callback so we can reattach if needed\n    this.listeners.set(event, callback);\n  }\n  unsubscribe(event) {\n    console.log('Unsubscribing from event:', event);\n\n    // Remove from socket if it exists\n    if (this.socket) {\n      this.socket.off(event);\n    }\n\n    // Always remove from our tracked listeners\n    this.listeners.delete(event);\n  }\n  subscribeToMatch(matchId) {\n    if (!this.socket) {\n      // Try to connect, but don't block if it fails\n      this.connect();\n      if (!this.socket || !this.socket.connected) {\n        console.log(`Cannot subscribe to match ${matchId}: No active socket connection`);\n        return;\n      }\n    }\n    console.log('Subscribing to match:', matchId);\n    this.socket.emit('subscribe_match', matchId);\n  }\n  unsubscribeFromMatch(matchId) {\n    if (!this.socket || !this.socket.connected) {\n      console.log(`Cannot unsubscribe from match ${matchId}: No active socket connection`);\n      return;\n    }\n    console.log('Unsubscribing from match:', matchId);\n    this.socket.emit('unsubscribe_match', matchId);\n  }\n}\nexport default new SocketService();","map":{"version":3,"names":["io","SocketService","constructor","_process$env$REACT_AP","_process$env$REACT_AP2","socket","listeners","Map","connectionAttempts","maxRetries","debug","isConnecting","reconnectTimer","hasConnectedBefore","socketUrl","process","env","REACT_APP_SOCKET_URL","trim","window","location","origin","apiUrl","REACT_APP_API_URL","console","log","NODE_ENV","connect","isMobile","detectDevice","reconnectionDelay","reconnection","reconnectionAttempts","transports","upgrade","rememberUpgrade","timeout","withCredentials","autoConnect","forceNew","path","query","device","timestamp","Date","now","on","latency","setupConnectionHandlers","error","handleConnectionError","_this$socket","_this$socket$io","_this$socket$io$engin","_this$socket$io$engin2","transport","engine","name","id","clearTimeout","requestLiveMatches","reason","handleReconnect","emitError","attempt","Error","userAgent","navigator","vendor","opera","test","toLowerCase","_error$message","_error$message$toLowe","_error$message$toLowe2","_error$message2","_error$message2$toLow","_error$message2$toLow2","message","isXHRError","call","includes","errorMessage","type","disconnect","backoffDelay","Math","min","pow","setTimeout","connected","emit","callback","get","removeAllListeners","clear","subscribe","event","set","data","unsubscribe","off","delete","subscribeToMatch","matchId","unsubscribeFromMatch"],"sources":["E:/Muqtasid BS Computer Science/SPRING-25/Project/ballinfo/frontend/src/services/socketService.js"],"sourcesContent":["import { io } from 'socket.io-client';\n\nclass SocketService {\n    constructor() {\n        this.socket = null;\n        this.listeners = new Map();\n        this.connectionAttempts = 0;\n        this.maxRetries = 3;\n        this.debug = true;\n        this.isConnecting = false;\n        this.reconnectTimer = null;\n        this.hasConnectedBefore = false;\n        \n        // Get the socket URL from environment variables or use a fallback\n        this.socketUrl = process.env.REACT_APP_SOCKET_URL?.trim() || window.location.origin;\n        this.apiUrl = process.env.REACT_APP_API_URL?.trim() || window.location.origin;\n        \n        if (this.debug) {\n            console.log('SocketService Configuration:', {\n                socketUrl: this.socketUrl,\n                apiUrl: this.apiUrl,\n                env: process.env.NODE_ENV\n            });\n        }\n    }\n\n    connect() {\n        if (this.socket || this.isConnecting) return;\n\n        this.isConnecting = true;\n        const isMobile = this.detectDevice() === 'mobile';\n        \n        console.log('Attempting to connect to:', this.socketUrl, 'Device type:', this.detectDevice());\n\n        try {\n            this.socket = io(this.socketUrl, {\n                reconnectionDelay: 1000,\n                reconnection: true,\n                reconnectionAttempts: 5,\n                transports: ['polling', 'websocket'],\n                upgrade: false,\n                rememberUpgrade: false,\n                timeout: 20000,\n                withCredentials: true,\n                autoConnect: true,\n                forceNew: true,\n                path: '/socket.io',\n                query: {\n                    device: this.detectDevice(),\n                    timestamp: Date.now(),\n                    debug: this.debug\n                }\n            });\n\n            // Add connection state logging\n            this.socket.io.on('ping', () => {\n                if (this.debug) console.log('Socket ping sent');\n            });\n\n            this.socket.io.on('pong', (latency) => {\n                if (this.debug) console.log('Socket pong received, latency:', latency, 'ms');\n            });\n\n            this.setupConnectionHandlers();\n        } catch (error) {\n            console.error('Error creating socket connection:', error);\n            this.handleConnectionError(error);\n        }\n    }\n\n    setupConnectionHandlers() {\n        if (!this.socket) return;\n\n        this.socket.on('connect', () => {\n            const transport = this.socket?.io?.engine?.transport?.name || 'unknown';\n            console.log('Socket connected successfully.', {\n                transport: transport,\n                id: this.socket.id,\n                device: this.detectDevice()\n            });\n            \n            this.connectionAttempts = 0;\n            this.isConnecting = false;\n            this.hasConnectedBefore = true;\n            clearTimeout(this.reconnectTimer);\n            \n            // Request live matches immediately after connection\n            this.requestLiveMatches();\n        });\n\n        this.socket.on('connect_error', (error) => {\n            console.error('Socket connection error:', error);\n            this.handleConnectionError(error);\n        });\n\n        this.socket.on('disconnect', (reason) => {\n            console.log('Socket disconnected. Reason:', reason);\n            this.isConnecting = false;\n            \n            if (reason === 'io client disconnect' || reason === 'io instance close') {\n                this.socket = null;\n                return;\n            }\n\n            if (reason === 'io server disconnect' || reason === 'transport close') {\n                this.handleReconnect();\n            }\n        });\n\n        this.socket.on('error', (error) => {\n            console.error('Socket error event:', error);\n            this.emitError(error);\n        });\n\n        // Monitor connection state\n        this.socket.io.on('reconnect_attempt', (attempt) => {\n            console.log(`Reconnection attempt ${attempt}`);\n        });\n\n        this.socket.io.on('reconnect_failed', () => {\n            console.log('Reconnection failed');\n            this.handleConnectionError(new Error('Reconnection failed'));\n        });\n    }\n\n    detectDevice() {\n        const userAgent = navigator.userAgent || navigator.vendor || window.opera;\n        const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());\n        return isMobile ? 'mobile' : 'desktop';\n    }\n\n    handleConnectionError(error) {\n        this.connectionAttempts++;\n        this.isConnecting = false;\n        \n        console.log(`Connection attempt ${this.connectionAttempts} failed:`, error.message);\n        \n        // Check if the error is related to XHR polling\n        const isXHRError = error.message?.toLowerCase?.()?.includes('xhr') || \n                          error.message?.toLowerCase?.()?.includes('polling');\n        \n        // Don't block UI or prevent navigation due to socket errors\n        if (this.connectionAttempts >= this.maxRetries || isXHRError) {\n            const errorMessage = {\n                type: 'CONNECTION_ERROR',\n                message: `Socket connection unavailable (${error.message}). App will continue to function without live updates.`,\n                isXHRError: isXHRError\n            };\n            console.error('Max retries reached or XHR error detected:', errorMessage);\n            this.emitError(errorMessage);\n            \n            // Clean up and don't retry\n            if (this.socket) {\n                this.socket.disconnect();\n                this.socket = null;\n            }\n            \n            this.isConnecting = false;\n            this.connectionAttempts = 0;\n            clearTimeout(this.reconnectTimer);\n        } else if (this.hasConnectedBefore) {\n            // Only try to reconnect if we've successfully connected before\n            this.handleReconnect();\n        } else {\n            // If we've never connected before, just clean up and give up\n            if (this.socket) {\n                this.socket.disconnect();\n                this.socket = null;\n            }\n            this.isConnecting = false;\n        }\n    }\n\n    handleReconnect() {\n        console.log('Attempting to reconnect...');\n        clearTimeout(this.reconnectTimer);\n\n        // Use exponential backoff with a cap\n        const backoffDelay = Math.min(2000 * Math.pow(1.5, this.connectionAttempts - 1), 8000);\n\n        this.reconnectTimer = setTimeout(() => {\n            if (this.socket) {\n                // Clear existing socket first\n                this.socket.disconnect();\n                this.socket = null;\n            }\n            // Create new connection\n            this.connect();\n        }, backoffDelay);\n    }\n\n    requestLiveMatches() {\n        if (!this.socket || !this.socket.connected) {\n            console.log('Cannot request matches: No active socket connection');       \n            return;\n        }\n        console.log('Requesting live matches from server');\n        this.socket.emit('request_live_matches');\n    }\n\n    emitError(error) {\n        const callback = this.listeners.get('error');\n        if (callback) {\n            callback(error);\n        }\n    }\n\n    disconnect() {\n        // Clear any pending reconnect attempts\n        clearTimeout(this.reconnectTimer);\n        \n        if (this.socket) {\n            try {\n                console.log('Disconnecting socket...');\n                \n                // Remove all listeners first to prevent reconnection triggers\n                this.socket.removeAllListeners();\n                this.socket.io.removeAllListeners();\n                \n                // Then disconnect\n                this.socket.disconnect();\n            } catch (error) {\n                console.error('Error during socket disconnect:', error);\n                // Continue with cleanup regardless of errors\n            } finally {\n                // Always reset socket state\n                this.socket = null;\n                this.connectionAttempts = 0;\n                this.isConnecting = false;\n                this.listeners.clear();\n            }\n        }\n    }\n\n    subscribe(event, callback) {\n        // Connect if needed, but don't block or throw errors\n        if (!this.socket) {\n            console.log('No socket connection, attempting to connect...');       \n            this.connect();\n            \n            // If still no socket, just record the listener without subscribing\n            if (!this.socket) {\n                console.log(`Saving listener for ${event} without socket connection`);\n                this.listeners.set(event, callback);\n                return;\n            }\n        }\n\n        console.log('Subscribing to event:', event);\n        \n        // Store callback and add listener if socket exists\n        if (this.socket) {\n            this.socket.on(event, (data) => {\n                if (this.debug) console.log(`Received ${event} event:`, data);\n                callback(data);\n            });\n        }\n        \n        // Always store the callback so we can reattach if needed\n        this.listeners.set(event, callback);\n    }\n\n    unsubscribe(event) {\n        console.log('Unsubscribing from event:', event);\n        \n        // Remove from socket if it exists\n        if (this.socket) {\n            this.socket.off(event);\n        }\n        \n        // Always remove from our tracked listeners\n        this.listeners.delete(event);\n    }\n\n    subscribeToMatch(matchId) {\n        if (!this.socket) {\n            // Try to connect, but don't block if it fails\n            this.connect();\n            if (!this.socket || !this.socket.connected) {\n                console.log(`Cannot subscribe to match ${matchId}: No active socket connection`);\n                return;\n            }\n        }\n        \n        console.log('Subscribing to match:', matchId);\n        this.socket.emit('subscribe_match', matchId);\n    }\n\n    unsubscribeFromMatch(matchId) {\n        if (!this.socket || !this.socket.connected) {\n            console.log(`Cannot unsubscribe from match ${matchId}: No active socket connection`);\n            return;\n        }\n        \n        console.log('Unsubscribing from match:', matchId);\n        this.socket.emit('unsubscribe_match', matchId);\n    }\n}\n\nexport default new SocketService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}